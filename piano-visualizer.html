<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Piano Visualizer</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a14;font-family:-apple-system,BlinkMacSystemFont,'Helvetica Neue',sans-serif;touch-action:none;-webkit-user-select:none;user-select:none}
canvas{display:block;width:100%;height:100%;position:fixed;top:0;left:0}
#startScreen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:10;background:radial-gradient(ellipse at center,#151530 0%,#0a0a14 100%)}
#startScreen h1{font-size:2.4rem;color:#e8e0ff;margin-bottom:.5rem;font-weight:300;letter-spacing:.15em}
#startScreen p{font-size:1rem;color:#8888aa;margin-bottom:2.5rem}
#startBtn{font-size:1.2rem;padding:1rem 3rem;border:1px solid rgba(180,160,255,.4);border-radius:50px;background:rgba(100,80,200,.15);color:#c8b8ff;cursor:pointer;transition:all .3s;-webkit-tap-highlight-color:transparent}
#startBtn:active{background:rgba(100,80,200,.35);transform:scale(.97)}
#themeBar{position:fixed;top:16px;right:16px;z-index:5;display:flex;gap:8px;opacity:0;transition:opacity .5s;pointer-events:none}
#themeBar.visible{opacity:1;pointer-events:auto}
.theme-dot{width:28px;height:28px;border-radius:50%;border:2px solid rgba(255,255,255,.2);cursor:pointer;transition:all .3s;-webkit-tap-highlight-color:transparent}
.theme-dot.active{border-color:#fff;transform:scale(1.15)}
.theme-dot:nth-child(1){background:linear-gradient(135deg,#6a5acd,#ff69b4)}
.theme-dot:nth-child(2){background:linear-gradient(135deg,#00bcd4,#4caf50)}
.theme-dot:nth-child(3){background:linear-gradient(135deg,#ff9800,#f44336)}
.theme-dot:nth-child(4){background:linear-gradient(135deg,#e0e0ff,#a0a0ff)}
#hud{position:fixed;top:0;left:0;right:0;z-index:4;pointer-events:none;display:none}
#encouragement{position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:6;font-size:1.6rem;color:rgba(255,255,255,.9);font-weight:300;letter-spacing:.15em;text-shadow:0 0 30px rgba(180,160,255,.6),0 0 60px rgba(180,160,255,.3);opacity:0;transition:opacity .5s,transform .5s;pointer-events:none}
#encouragement.visible{opacity:1;transform:translateX(-50%) scale(1)}
#encouragement.entering{opacity:0;transform:translateX(-50%) scale(0.8)}
#flowGauge{position:fixed;left:12px;top:50%;transform:translateY(-50%);width:14px;height:60vh;max-height:400px;border-radius:7px;background:rgba(255,255,255,.08);overflow:hidden}
#flowFill{position:absolute;bottom:0;width:100%;border-radius:7px;transition:height .3s,background .5s;height:0%}
#stageLabel{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);font-size:1rem;color:rgba(255,255,255,.5);letter-spacing:.15em;font-weight:300;opacity:0;transition:opacity .8s}
#stageLabel.visible{opacity:1}
#noteDisplay{position:fixed;bottom:50px;left:50%;transform:translateX(-50%);z-index:5;font-size:1.6rem;color:rgba(255,255,255,.6);font-weight:200;letter-spacing:.2em;text-shadow:0 0 20px rgba(180,160,255,.5);opacity:0;transition:opacity .4s;pointer-events:none}
#noteDisplay.visible{opacity:1}
#sessionStatus{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);z-index:5;font-size:.85rem;color:rgba(255,255,255,.4);letter-spacing:.12em;font-weight:300;opacity:0;transition:opacity .6s;pointer-events:none}
#sessionStatus.visible{opacity:1}
#qualityScore{position:fixed;top:55px;left:50%;transform:translateX(-50%);z-index:5;font-size:.7rem;color:rgba(255,255,255,.25);letter-spacing:.08em;opacity:0;transition:opacity .5s;pointer-events:none}
#qualityScore.visible{opacity:1}
#debugOverlay{position:fixed;bottom:4px;left:4px;z-index:20;font-size:11px;font-family:'SF Mono',Menlo,monospace;color:rgba(0,255,150,.7);background:rgba(0,0,0,.6);padding:6px 10px;border-radius:6px;pointer-events:none;display:none;line-height:1.5;white-space:pre}
</style>
</head>
<body>
<div id="startScreen">
  <h1>Piano Visualizer</h1>
  <p>ピアノを弾くと画面がきれいに光るよ</p>
  <button id="startBtn">タップしてスタート</button>
</div>
<canvas id="canvas"></canvas>
<div id="hud">
  <div id="encouragement"></div>
  <div id="flowGauge"><div id="flowFill"></div></div>
  <div id="stageLabel"></div>
</div>
<div id="themeBar">
  <div class="theme-dot active" data-theme="0"></div>
  <div class="theme-dot" data-theme="1"></div>
  <div class="theme-dot" data-theme="2"></div>
  <div class="theme-dot" data-theme="3"></div>
</div>
<div id="noteDisplay"></div>
<div id="sessionStatus"></div>
<div id="qualityScore"></div>
<div id="debugOverlay"></div>
<script>
'use strict';

// ========================================
// v9 — Piano Visualizer
// ========================================
// Improvements over v8:
//   1. Harmonicity gate — checks harmonic partial energy ratio
//      to reject voice/speech (piano has strong integer-ratio harmonics)
//   2. Tightened onset thresholds (flatness, crest, spread)
//   3. AGC voice suppression — limits gain when non-piano audio persists
//   4. Encouraging words system — replaces numeric combo display
//      with escalating warm messages + special visual effects
//   5. Enhanced stage transitions — more particles, celebration effects
//   6. Warmer quality labels
// ========================================

const CONFIG = {
  // Audio — main analyser (for pitch + visualisation)
  FFT_SIZE: 4096,
  SMOOTHING: 0.82,
  PIANO_FREQ_MIN: 27,
  PIANO_FREQ_MAX: 4200,

  // Onset analyser — dedicated low-smoothing node for transient detection
  ONSET_FFT_SIZE: 2048,
  ONSET_SMOOTHING: 0.15,

  // =============================================
  // Software AGC via GainNode (v8)
  // =============================================
  AGC_TARGET_RMS: 0.06,
  AGC_ATTACK_COEFF: 0.02,
  AGC_RELEASE_COEFF: 0.08,
  AGC_MIN_GAIN: 1.0,
  AGC_MAX_GAIN: 40.0,
  AGC_UPDATE_INTERVAL_MS: 100,
  AGC_SILENCE_FLOOR: 0.0003,

  // v9: AGC voice suppression
  AGC_VOICE_REJECT_COUNT: 5,      // consecutive high-RMS rejections to trigger suppression
  AGC_VOICE_SUPPRESS_MAX: 8.0,    // temporary max gain during voice suppression
  AGC_VOICE_SUPPRESS_MS: 500,     // how long to suppress after voice detected
  AGC_VOICE_RMS_MIN: 0.02,        // minimum RMS to count as "high-RMS rejection"

  // =============================================
  // YIN Pitch Detection (v6+)
  // =============================================
  YIN_THRESHOLD: 0.20,
  YIN_PROBABILITY_THRESHOLD: 0.10,
  RMS_SILENCE_THRESHOLD: 0.010,
  PITCH_MIN_HZ: 25,
  PITCH_MAX_HZ: 5000,
  GOOD_NOTE_RMS: 0.015,
  CONFIDENCE_THRESHOLD: 0.30,

  // =============================================
  // Multi-Feature Onset Classification (v9 — tightened)
  // =============================================
  SPECTRAL_FLUX_THRESHOLD: 6.0,
  SPECTRAL_FLUX_ADAPTIVE_K: 1.3,
  SPECTRAL_FLUX_HISTORY_SIZE: 20,
  ONSET_SPREAD_THRESHOLD: 0.15,       // v9: was 0.10 — piano onsets are broader
  ONSET_SPREAD_MIN_CHANGE: 1.5,
  FLATNESS_PIANO_MIN: 0.12,           // v9: was 0.08 — filters more voice
  CREST_VOICE_MAX: 8.0,               // v9: was 12.0 — piano attacks are peakier
  ONSET_GATE_DURATION_MS: 1500,
  ONSET_COOLDOWN_MS: 60,
  FLUX_FREQ_MIN_HZ: 60,
  FLUX_FREQ_MAX_HZ: 4200,

  // =============================================
  // Harmonicity Gate (v9 — new)
  // =============================================
  HARMONICITY_MIN: 0.20,              // minimum harmonic energy ratio to pass gate
  HARMONICITY_PARTIALS: 6,            // number of harmonics to check (2x..7x)
  HARMONICITY_BIN_TOLERANCE: 2,       // ±bins around each harmonic peak

  // =============================================
  // Session Confidence Layer (v7+)
  // =============================================
  SESSION_WINDOW_MS: 4000,
  SESSION_CONFIRM_THRESHOLD: 0.35,
  SESSION_LOSE_THRESHOLD: 0.10,
  SESSION_WARMUP_MS: 2000,
  SESSION_SAMPLE_INTERVAL_MS: 50,

  // =============================================
  // Spectral Centroid Tracking (debug only)
  // =============================================
  CENTROID_HISTORY_SIZE: 20,

  // =============================================
  // Quality Scoring — simplified for kids (v8+)
  // =============================================
  SCORE_RHYTHM_WEIGHT: 0.5,
  SCORE_DYNAMICS_WEIGHT: 0.5,
  IOI_HISTORY_SIZE: 16,
  IOI_IDEAL_CV: 0.30,
  IOI_MAX_CV: 1.5,
  AMPLITUDE_HISTORY_SIZE: 30,
  DYNAMICS_IDEAL_CV_MIN: 0.03,
  DYNAMICS_IDEAL_CV_MAX: 0.60,
  SCORE_UPDATE_INTERVAL_MS: 500,
  SCORE_SMOOTHING: 0.08,

  // Game timing
  COMBO_WINDOW_MS: 2200,
  SILENCE_DECAY_START_MS: 1000,
  SILENCE_HARD_DECAY_MS: 3500,
  NOISE_PENALTY_COOLDOWN_MS: 300,
  NOTE_DISPLAY_DURATION_MS: 1200,
  MIN_NOTE_INTERVAL_MS: 70,

  // Game balance
  FLOW_GAIN_BASE: 16,
  FLOW_GAIN_COMBO_MAX: 16,
  FLOW_GAIN_STABILITY_MAX: 20,
  FLOW_GAIN_QUALITY_MAX: 25,
  FLOW_DECAY_SOFT: 6,
  FLOW_DECAY_HARD: 12,
  NOISE_RMS_THRESHOLD: 0.05,
  FLOW_NOISE_PENALTY: 3,
  COMBO_DECAY_RATE: 1,
  COMBO_NOISE_PENALTY: 1,

  // Pitch stability
  STABILITY_SEMITONE_THRESHOLD: 3,
  STABILITY_GROWTH: 0.05,
  STABILITY_DECAY_GOOD: 0.85,
  STABILITY_DECAY_IDLE: 0.98,

  // Rendering
  MAX_PARTICLES: 800,
  SHADOW_BLUR_ENABLED: true,
  AMBIENT_PARTICLE_CHANCE: 0.03,
  BAR_COUNT: 64,

  // Stages
  STAGES: [
    { name: '', minFlow: 0 },
    { name: '\u2726 めざめ', minFlow: 15 },
    { name: '\u2726\u2726 はなひらく', minFlow: 35 },
    { name: '\u2726\u2726\u2726 オーロラ', minFlow: 55 },
    { name: '\u2726\u2726\u2726\u2726 コスモス', minFlow: 75 },
    { name: '\u2726\u2726\u2726\u2726\u2726 かがやき', minFlow: 90 }
  ],

  // =============================================
  // Encouragement Tiers (v9 — replaces combo numbers)
  // =============================================
  ENCOURAGEMENT_TIERS: [
    { minCombo: 3,   message: 'いいよ！',         effect: 'glowPulse' },
    { minCombo: 8,   message: 'すごい！',         effect: 'glowParticles' },
    { minCombo: 15,  message: 'のってきた！',     effect: 'colorWave' },
    { minCombo: 25,  message: 'きらきら！',       effect: 'starShower' },
    { minCombo: 40,  message: 'すてきなおと！',   effect: 'flowerBurst' },
    { minCombo: 60,  message: 'まほうみたい！',   effect: 'shimmer' },
    { minCombo: 80,  message: 'かがやいてる！',   effect: 'radiance' },
    { minCombo: 100, message: 'さいこう！',       effect: 'goldenBurst' }
  ],
  ENCOURAGEMENT_COOLDOWN_MS: 8000,   // don't repeat same tier within this window
  ENCOURAGEMENT_DISPLAY_MS: 2500,    // how long message stays visible

  // Note mapping
  NOTE_NAMES: ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'],
  PIANO_KEY_MIN: 21,
  PIANO_KEY_COUNT: 88,

  // Themes
  THEMES: [
    { bg: [10,10,20], colors: ['#8b5cf6','#a855f7','#d946ef','#ec4899','#6366f1','#818cf8'], glow: 'rgba(139,92,246,' },
    { bg: [8,18,20], colors: ['#06b6d4','#22d3ee','#34d399','#10b981','#14b8a6','#67e8f9'], glow: 'rgba(6,182,212,' },
    { bg: [20,12,8], colors: ['#f97316','#fb923c','#ef4444','#f43f5e','#eab308','#fbbf24'], glow: 'rgba(249,115,22,' },
    { bg: [12,12,18], colors: ['#e0e7ff','#c7d2fe','#a5b4fc','#ddd6fe','#f0f0ff','#ffffff'], glow: 'rgba(200,200,255,' }
  ]
};

// ========================================
// DOM references
// ========================================
const DOM = {
  canvas: document.getElementById('canvas'),
  startScreen: document.getElementById('startScreen'),
  startBtn: document.getElementById('startBtn'),
  themeBar: document.getElementById('themeBar'),
  hud: document.getElementById('hud'),
  encouragement: document.getElementById('encouragement'),
  flowFill: document.getElementById('flowFill'),
  stageLabel: document.getElementById('stageLabel'),
  noteDisplay: document.getElementById('noteDisplay'),
  sessionStatus: document.getElementById('sessionStatus'),
  qualityScore: document.getElementById('qualityScore'),
  debugOverlay: document.getElementById('debugOverlay')
};
const ctx = DOM.canvas.getContext('2d');

// ========================================
// Game State
// ========================================
const state = {
  running: false,
  flow: 0,
  combo: 0,
  bestCombo: 0,
  currentStage: 0,
  lastGoodNoteTimeMs: 0,
  lastSilenceStartMs: -1,
  lastNoisePenaltyMs: 0,
  lastPitch: -1,
  pitchStability: 0,
  lastNoteTimeMs: 0,
  smoothEnergy: 0,
  lastDetectedNote: '',
  noteShowTimeMs: 0,
  currentTheme: 0,
  lastFrameTimeMs: 0,
  prevSpectrum: null,
  spectralFluxHistory: [],
  lastOnsetTimeMs: -9999,

  // Software AGC (v8)
  agcGain: 1.0,
  agcSmoothedRms: 0,
  agcLastUpdateMs: 0,

  // v9: AGC voice suppression
  agcVoiceRejectCount: 0,
  agcVoiceSuppressUntilMs: 0,

  // Session Confidence
  sessionSamples: [],
  sessionState: 'waiting',
  sessionStartMs: 0,
  sessionConfidence: 0,
  sessionPerformingStartMs: 0,
  lastSessionSampleMs: 0,

  // Quality Scoring
  noteOnsetTimes: [],
  ioiHistory: [],
  amplitudeHistory: [],
  centroidHistory: [],
  rhythmScore: 0,
  dynamicsScore: 0,
  qualityScore: 0,
  displayedQualityScore: 0,
  lastScoreUpdateMs: 0,

  // v9: Encouragement system
  currentEncouragementTier: -1,
  lastEncouragementTimeMs: 0,
  encouragementHideTimeMs: 0,

  // v9: Special effects state
  glowPulseIntensity: 0,
  shimmerPhase: -1,
  shimmerStartMs: 0,

  // Debug
  debugMode: false,
  debugLastFlux: 0,
  debugLastSpread: 0,
  debugLastThreshold: 0,
  debugGateOpen: false,
  debugLastRms: 0,
  debugLastConf: 0,
  debugLastPitch: 0,
  debugIsGoodNote: false,
  debugLastFlatness: 0,
  debugLastCrest: 0,
  debugOnsetReason: '',
  debugLastCentroid: 0,
  debugCentroidCV: 0,
  debugSessionConf: 0,
  debugSessionState: 'waiting',
  debugAgcGain: 1.0,
  debugHarmonicity: 0
};

// ========================================
// Audio — dual analyser + software AGC
// ========================================
let audioCtx;
let analyser;
let onsetAnalyser;
let gainNode;
let dataArray, freqArray;
let onsetDataArray;

async function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }

  const constraints = {
    audio: {
      autoGainControl: false,
      noiseSuppression: false,
      echoCancellation: false,
      sampleRate: { ideal: 48000 }
    }
  };

  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  const source = audioCtx.createMediaStreamSource(stream);

  gainNode = audioCtx.createGain();
  gainNode.gain.setValueAtTime(1.0, audioCtx.currentTime);
  source.connect(gainNode);

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = CONFIG.FFT_SIZE;
  analyser.smoothingTimeConstant = CONFIG.SMOOTHING;
  gainNode.connect(analyser);
  dataArray = new Uint8Array(analyser.frequencyBinCount);
  freqArray = new Float32Array(analyser.fftSize);

  onsetAnalyser = audioCtx.createAnalyser();
  onsetAnalyser.fftSize = CONFIG.ONSET_FFT_SIZE;
  onsetAnalyser.smoothingTimeConstant = CONFIG.ONSET_SMOOTHING;
  gainNode.connect(onsetAnalyser);
  onsetDataArray = new Uint8Array(onsetAnalyser.frequencyBinCount);
}

// ========================================
// Canvas
// ========================================
let W, H;
function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  DOM.canvas.width = W * dpr;
  DOM.canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if (state.running) initBgStars();
}
resize();
window.addEventListener('resize', resize);

// ========================================
// Debug toggle — triple-tap bottom-left
// ========================================
let debugTapCount = 0;
let debugTapTimer = 0;
document.addEventListener('click', (e) => {
  if (e.clientX < 80 && e.clientY > H - 80) {
    debugTapCount++;
    clearTimeout(debugTapTimer);
    debugTapTimer = setTimeout(() => { debugTapCount = 0; }, 600);
    if (debugTapCount >= 3) {
      state.debugMode = !state.debugMode;
      DOM.debugOverlay.style.display = state.debugMode ? 'block' : 'none';
      debugTapCount = 0;
    }
  }
});

// ========================================
// Theme switching
// ========================================
document.querySelectorAll('.theme-dot').forEach(d => {
  d.addEventListener('click', () => {
    document.querySelector('.theme-dot.active')?.classList.remove('active');
    d.classList.add('active');
    state.currentTheme = parseInt(d.dataset.theme);
  });
});

// ========================================
// Particle System
// ========================================
class Particle {
  constructor(x, y, color, size, vx, vy, life, type) {
    this.x = x; this.y = y; this.color = color; this.size = size;
    this.vx = vx; this.vy = vy; this.life = life; this.maxLife = life;
    this.type = type || 'circle';
    this.angle = Math.random() * Math.PI * 2;
    this.spin = (Math.random() - 0.5) * 0.04;
  }

  update() {
    this.x += this.vx; this.y += this.vy;
    this.vy += 0.012; this.vx *= 0.997;
    this.life--; this.angle += this.spin;
  }

  draw(c) {
    const a = Math.max(0, this.life / this.maxLife);
    const s = this.size * (0.4 + 0.6 * a);
    c.save();
    c.globalAlpha = a;
    c.translate(this.x, this.y);
    c.rotate(this.angle);
    const useShadow = CONFIG.SHADOW_BLUR_ENABLED && particles.length < 400;

    if (this.type === 'circle') {
      c.beginPath(); c.arc(0, 0, s, 0, Math.PI * 2);
      c.fillStyle = this.color;
      if (useShadow) { c.shadowColor = this.color; c.shadowBlur = s * 2; }
      c.fill();
    } else if (this.type === 'ring') {
      c.beginPath(); c.arc(0, 0, s, 0, Math.PI * 2);
      c.strokeStyle = this.color; c.lineWidth = 1.5;
      if (useShadow) { c.shadowColor = this.color; c.shadowBlur = s; }
      c.stroke();
    } else if (this.type === 'star') {
      drawStar(c, 0, 0, 5, s, s * 0.45, this.color, useShadow);
    } else if (this.type === 'note') {
      c.font = s * 2.5 + 'px serif';
      c.fillStyle = this.color;
      if (useShadow) { c.shadowColor = this.color; c.shadowBlur = 10; }
      c.textAlign = 'center'; c.textBaseline = 'middle';
      c.fillText('\u266A', 0, 0);
    } else if (this.type === 'flower') {
      drawFlower(c, 0, 0, s, this.color, a, useShadow);
    }
    c.restore();
  }
}

function drawStar(c, cx, cy, sp, oR, iR, col, useShadow) {
  c.beginPath();
  for (let i = 0; i < sp * 2; i++) {
    const r = i % 2 === 0 ? oR : iR;
    const a = (Math.PI * i) / sp - Math.PI / 2;
    if (i === 0) c.moveTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
    else c.lineTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
  }
  c.closePath(); c.fillStyle = col;
  if (useShadow) { c.shadowColor = col; c.shadowBlur = oR * 1.5; }
  c.fill();
}

function drawFlower(c, cx, cy, s, col, a, useShadow) {
  c.fillStyle = col;
  if (useShadow) { c.shadowColor = col; c.shadowBlur = s; }
  for (let i = 0; i < 5; i++) {
    const angle = (Math.PI * 2 * i) / 5;
    c.beginPath();
    c.ellipse(cx + Math.cos(angle) * s * 0.5, cy + Math.sin(angle) * s * 0.5, s * 0.5, s * 0.25, angle, 0, Math.PI * 2);
    c.fill();
  }
  c.shadowBlur = 0;
  c.beginPath(); c.arc(cx, cy, s * 0.25, 0, Math.PI * 2);
  c.fillStyle = 'rgba(255,255,200,' + a + ')'; c.fill();
}

let particles = [];

function spawnBurst(x, y, count, energy) {
  const cols = CONFIG.THEMES[state.currentTheme].colors;
  const typePool = ['circle', 'circle', 'ring', 'star', 'note'];
  if (state.flow > 35) typePool.push('flower');
  if (state.flow > 60) typePool.push('star', 'star');
  const actualCount = Math.min(count, CONFIG.MAX_PARTICLES - particles.length);
  for (let i = 0; i < actualCount; i++) {
    const ang = Math.random() * Math.PI * 2;
    const spd = 1 + Math.random() * 3.5 * energy;
    particles.push(new Particle(
      x, y,
      cols[Math.floor(Math.random() * cols.length)],
      3 + Math.random() * 9 * energy,
      Math.cos(ang) * spd, Math.sin(ang) * spd - 1.2,
      70 + Math.random() * 90,
      typePool[Math.floor(Math.random() * typePool.length)]
    ));
  }
}

function spawnStream(x, y, energy) {
  const cols = CONFIG.THEMES[state.currentTheme].colors;
  const count = 2 + Math.floor(state.flow / 25);
  for (let i = 0; i < count; i++) {
    if (particles.length >= CONFIG.MAX_PARTICLES) break;
    particles.push(new Particle(
      x + (Math.random() - 0.5) * 40, y,
      cols[Math.floor(Math.random() * cols.length)],
      2 + Math.random() * 5 * energy,
      (Math.random() - 0.5) * 1.2, -1.5 - Math.random() * 2.5 * energy,
      90 + Math.random() * 70,
      Math.random() > 0.6 ? 'note' : 'circle'
    ));
  }
}

// ========================================
// v9: Encouragement Effects
// ========================================

function effectGlowPulse() {
  state.glowPulseIntensity = 0.4;
}

function effectGlowParticles() {
  state.glowPulseIntensity = 0.5;
  spawnBurst(W / 2, H * 0.3, 5, 0.6);
}

function effectColorWave() {
  state.glowPulseIntensity = 0.6;
  const cols = CONFIG.THEMES[state.currentTheme].colors;
  for (let i = 0; i < 8; i++) {
    const ang = (Math.PI * 2 * i) / 8;
    const dist = 80;
    ripples.push(new Ripple(W / 2 + Math.cos(ang) * dist, H * 0.4 + Math.sin(ang) * dist,
      cols[i % cols.length], 250 + state.flow * 2));
  }
}

function effectStarShower(count) {
  const cols = CONFIG.THEMES[state.currentTheme].colors;
  const n = count || 12;
  for (let i = 0; i < n; i++) {
    if (particles.length >= CONFIG.MAX_PARTICLES) break;
    particles.push(new Particle(
      Math.random() * W, -10,
      cols[Math.floor(Math.random() * cols.length)],
      4 + Math.random() * 8,
      (Math.random() - 0.5) * 1.5, 1 + Math.random() * 2,
      120 + Math.random() * 80,
      'star'
    ));
  }
}

function effectFlowerBurst() {
  state.glowPulseIntensity = 0.7;
  const cols = CONFIG.THEMES[state.currentTheme].colors;
  for (let i = 0; i < 15; i++) {
    if (particles.length >= CONFIG.MAX_PARTICLES) break;
    const ang = Math.random() * Math.PI * 2;
    const spd = 1.5 + Math.random() * 3;
    particles.push(new Particle(
      W / 2, H * 0.4,
      cols[Math.floor(Math.random() * cols.length)],
      5 + Math.random() * 10,
      Math.cos(ang) * spd, Math.sin(ang) * spd - 1.5,
      100 + Math.random() * 80,
      'flower'
    ));
  }
}

function effectShimmer() {
  state.shimmerPhase = 0;
  state.shimmerStartMs = performance.now();
  state.glowPulseIntensity = 0.8;
  spawnBurst(W / 2, H * 0.4, 20, 1.0);
  effectStarShower(8);
}

function effectRadiance() {
  state.glowPulseIntensity = 1.0;
  effectStarShower(15);
  for (let i = 0; i < 12; i++) {
    if (particles.length >= CONFIG.MAX_PARTICLES) break;
    const ang = (Math.PI * 2 * i) / 12;
    ripples.push(new Ripple(W / 2, H * 0.4,
      CONFIG.THEMES[state.currentTheme].colors[i % 6], 300 + i * 30));
  }
}

function effectGoldenBurst() {
  state.glowPulseIntensity = 1.0;
  state.shimmerPhase = 0;
  state.shimmerStartMs = performance.now();
  const goldColors = ['#ffd700', '#ffec8b', '#fff8dc', '#ffe4b5', '#ffc125', '#eec900'];
  for (let i = 0; i < 30; i++) {
    if (particles.length >= CONFIG.MAX_PARTICLES) break;
    const ang = Math.random() * Math.PI * 2;
    const spd = 2 + Math.random() * 4;
    particles.push(new Particle(
      W / 2, H * 0.35,
      goldColors[Math.floor(Math.random() * goldColors.length)],
      4 + Math.random() * 12,
      Math.cos(ang) * spd, Math.sin(ang) * spd - 2,
      100 + Math.random() * 100,
      Math.random() > 0.5 ? 'star' : 'circle'
    ));
  }
  effectStarShower(10);
}

function triggerEffect(effectName) {
  switch (effectName) {
    case 'glowPulse': effectGlowPulse(); break;
    case 'glowParticles': effectGlowParticles(); break;
    case 'colorWave': effectColorWave(); break;
    case 'starShower': effectStarShower(12); break;
    case 'flowerBurst': effectFlowerBurst(); break;
    case 'shimmer': effectShimmer(); break;
    case 'radiance': effectRadiance(); break;
    case 'goldenBurst': effectGoldenBurst(); break;
  }
}

function showEncouragement(tierIndex, timeMs) {
  const tier = CONFIG.ENCOURAGEMENT_TIERS[tierIndex];
  if (!tier) return;

  // Check cooldown — don't show same or lower tier too frequently
  if (timeMs - state.lastEncouragementTimeMs < CONFIG.ENCOURAGEMENT_COOLDOWN_MS
      && tierIndex <= state.currentEncouragementTier) return;

  state.currentEncouragementTier = tierIndex;
  state.lastEncouragementTimeMs = timeMs;
  state.encouragementHideTimeMs = timeMs + CONFIG.ENCOURAGEMENT_DISPLAY_MS;

  // Show message with animation
  DOM.encouragement.textContent = tier.message;
  DOM.encouragement.classList.remove('visible');
  DOM.encouragement.classList.add('entering');

  // Force reflow for animation restart
  void DOM.encouragement.offsetWidth;

  DOM.encouragement.classList.remove('entering');
  DOM.encouragement.classList.add('visible');

  // Trigger visual effect
  triggerEffect(tier.effect);
}

// ========================================
// Ripples
// ========================================
let ripples = [];
class Ripple {
  constructor(x, y, color, size) {
    this.x = x; this.y = y; this.radius = 0;
    this.maxRadius = size || 200; this.color = color; this.life = 1;
  }
  update() {
    this.radius += 2.5 + state.flow * 0.03;
    this.life = 1 - this.radius / this.maxRadius;
  }
  draw(c) {
    if (this.life <= 0) return;
    c.save();
    c.globalAlpha = this.life * 0.3;
    c.beginPath(); c.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    c.strokeStyle = this.color;
    c.lineWidth = 1.5 + state.flow * 0.02;
    if (CONFIG.SHADOW_BLUR_ENABLED && ripples.length < 15) {
      c.shadowColor = this.color;
      c.shadowBlur = 10 + state.flow * 0.15;
    }
    c.stroke();
    c.restore();
  }
}

// ========================================
// Background Elements
// ========================================
let bgStars = [];

function initBgStars() {
  bgStars = [];
  for (let i = 0; i < 80; i++) {
    bgStars.push({
      x: Math.random() * W, y: Math.random() * H,
      size: Math.random() * 2 + 0.5,
      twinkle: Math.random() * Math.PI * 2,
      speed: 0.01 + Math.random() * 0.02
    });
  }
}

function drawBgStars(time) {
  const visibility = Math.min(1, state.flow / 30);
  if (visibility < 0.01) return;
  const cols = CONFIG.THEMES[state.currentTheme].colors;
  ctx.save();
  for (const s of bgStars) {
    s.twinkle += s.speed;
    const a = visibility * (0.3 + 0.7 * (Math.sin(s.twinkle) * 0.5 + 0.5));
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size * (1 + state.flow * 0.01), 0, Math.PI * 2);
    ctx.fillStyle = cols[Math.floor(s.twinkle) % cols.length] || '#fff';
    ctx.fill();
  }
  ctx.restore();
}

function drawAurora(time) {
  const intensity = Math.max(0, (state.flow - 40) / 60);
  if (intensity < 0.01) return;
  const theme = CONFIG.THEMES[state.currentTheme];
  ctx.save();
  ctx.globalAlpha = intensity * 0.15;
  for (let band = 0; band < 3; band++) {
    ctx.beginPath();
    ctx.moveTo(0, H * 0.3 + band * 40);
    for (let x = 0; x <= W; x += 20) {
      const y = H * 0.3 + band * 40
        + Math.sin(x * 0.005 + time * 0.0008 + band) * 50 * intensity
        + Math.sin(x * 0.01 + time * 0.001) * 25 * intensity;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(W, H); ctx.lineTo(0, H); ctx.closePath();
    const grad = ctx.createLinearGradient(0, H * 0.2, 0, H * 0.7);
    grad.addColorStop(0, theme.colors[band % theme.colors.length]);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fill();
  }
  ctx.restore();
}

function drawGroundFlowers(time) {
  const intensity = Math.max(0, (state.flow - 55) / 45);
  if (intensity < 0.01) return;
  ctx.save();
  ctx.globalAlpha = intensity * 0.5;
  const cols = CONFIG.THEMES[state.currentTheme].colors;
  const count = Math.floor(intensity * 12);
  for (let i = 0; i < count; i++) {
    const x = (i / (count - 1 || 1)) * W;
    const baseY = H - 20;
    const sway = Math.sin(time * 0.001 + i * 0.7) * 5;
    const s = 4 + intensity * 6;
    ctx.strokeStyle = 'rgba(100,180,100,' + intensity * 0.4 + ')';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x, baseY); ctx.lineTo(x + sway, baseY - 20 - s * 2); ctx.stroke();
    drawFlower(ctx, x + sway, baseY - 20 - s * 2, s, cols[i % cols.length], intensity, false);
  }
  ctx.restore();
}

// ========================================
// YIN Pitch Detection (v6+)
// ========================================
function freqToNote(f) {
  if (f < CONFIG.PITCH_MIN_HZ || f > CONFIG.PITCH_MAX_HZ) return null;
  const n = 12 * (Math.log2(f / 440)) + 69;
  const r = Math.round(n);
  return {
    name: CONFIG.NOTE_NAMES[r % 12],
    octave: Math.floor(r / 12) - 1,
    noteNum: r,
    freq: f
  };
}

let yinDiffBuf = null;
let yinCMNDFBuf = null;

function detectPitchYIN(buf, sr) {
  const SIZE = buf.length;
  let rms = 0;
  for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
  rms = Math.sqrt(rms / SIZE);
  if (rms < CONFIG.RMS_SILENCE_THRESHOLD) return { pitch: -1, conf: 0, rms: rms };

  const halfLen = Math.floor(SIZE / 2);
  const tauMin = Math.floor(sr / CONFIG.PITCH_MAX_HZ);
  const tauMax = Math.min(halfLen, Math.floor(sr / CONFIG.PITCH_MIN_HZ));

  if (tauMax <= tauMin + 2) return { pitch: -1, conf: 0, rms: rms };

  if (!yinDiffBuf || yinDiffBuf.length < tauMax + 1) {
    yinDiffBuf = new Float32Array(tauMax + 1);
    yinCMNDFBuf = new Float32Array(tauMax + 1);
  }
  const diff = yinDiffBuf;
  diff[0] = 0;

  for (let tau = 1; tau <= tauMax; tau++) {
    let sum = 0;
    for (let j = 0; j < halfLen; j++) {
      const delta = buf[j] - buf[j + tau];
      sum += delta * delta;
    }
    diff[tau] = sum;
  }

  const cmndf = yinCMNDFBuf;
  cmndf[0] = 1;
  let runningSum = 0;
  for (let tau = 1; tau <= tauMax; tau++) {
    runningSum += diff[tau];
    cmndf[tau] = (runningSum > 0) ? diff[tau] * tau / runningSum : 0;
  }

  let bestTau = -1;
  for (let tau = tauMin; tau < tauMax; tau++) {
    if (cmndf[tau] < CONFIG.YIN_THRESHOLD) {
      while (tau + 1 < tauMax && cmndf[tau + 1] < cmndf[tau]) {
        tau++;
      }
      bestTau = tau;
      break;
    }
  }

  if (bestTau < 0) {
    let minVal = Infinity;
    for (let tau = tauMin; tau <= tauMax; tau++) {
      if (cmndf[tau] < minVal) {
        minVal = cmndf[tau];
        bestTau = tau;
      }
    }
    if (minVal > 0.5) return { pitch: -1, conf: 0, rms: rms };
  }

  let refinedTau = bestTau;
  if (bestTau > 0 && bestTau < tauMax) {
    const s0 = diff[bestTau - 1];
    const s1 = diff[bestTau];
    const s2 = diff[bestTau + 1];
    const denom = 2 * (2 * s1 - s0 - s2);
    if (Math.abs(denom) > 1e-10) {
      refinedTau = bestTau + (s0 - s2) / denom;
    }
  }

  if (refinedTau <= 0) return { pitch: -1, conf: 0, rms: rms };

  const pitch = sr / refinedTau;
  const conf = 1 - cmndf[bestTau];

  if (pitch < CONFIG.PITCH_MIN_HZ || pitch > CONFIG.PITCH_MAX_HZ) {
    return { pitch: -1, conf: conf, rms: rms };
  }
  if (conf < CONFIG.YIN_PROBABILITY_THRESHOLD) {
    return { pitch: -1, conf: conf, rms: rms };
  }

  return { pitch: pitch, conf: conf, rms: rms };
}

// ========================================
// Spectral Features
// ========================================

function computeSpectralFlatness(spectrum, startBin, endBin) {
  const n = endBin - startBin;
  if (n < 2) return 0;
  let logSum = 0;
  let arithSum = 0;
  let validBins = 0;
  for (let i = startBin; i < endBin; i++) {
    const val = spectrum[i] + 1e-10;
    logSum += Math.log(val);
    arithSum += val;
    validBins++;
  }
  if (validBins === 0 || arithSum < 1e-8) return 0;
  const geometricMean = Math.exp(logSum / validBins);
  const arithmeticMean = arithSum / validBins;
  return geometricMean / arithmeticMean;
}

function computeSpectralCrest(spectrum, startBin, endBin) {
  const n = endBin - startBin;
  if (n < 2) return 0;
  let maxVal = 0;
  let sum = 0;
  for (let i = startBin; i < endBin; i++) {
    if (spectrum[i] > maxVal) maxVal = spectrum[i];
    sum += spectrum[i];
  }
  const mean = sum / n;
  if (mean < 1e-8) return 0;
  return maxVal / mean;
}

function computeSpectralCentroid(spectrum, startBin, endBin, binHz) {
  let weightedSum = 0;
  let totalEnergy = 0;
  for (let i = startBin; i < endBin; i++) {
    const val = spectrum[i];
    weightedSum += val * (i * binHz);
    totalEnergy += val;
  }
  if (totalEnergy < 1e-8) return 0;
  return weightedSum / totalEnergy;
}

function coefficientOfVariation(arr) {
  if (arr.length < 3) return 0;
  let mean = 0;
  for (let i = 0; i < arr.length; i++) mean += arr[i];
  mean /= arr.length;
  if (Math.abs(mean) < 1e-10) return 0;
  let variance = 0;
  for (let i = 0; i < arr.length; i++) {
    const d = arr[i] - mean;
    variance += d * d;
  }
  variance /= arr.length;
  return Math.sqrt(variance) / Math.abs(mean);
}

// ========================================
// v9: Harmonicity — checks harmonic partial energy
// ========================================
// Piano sound has strong energy at integer multiples of the fundamental.
// Voice (especially vowels) has formant peaks that don't align as well.
// Returns ratio of harmonic energy to total energy (0-1).
function computeHarmonicity(spectrum, fundamentalBin, startBin, endBin) {
  if (fundamentalBin <= 0 || fundamentalBin >= endBin) return 0;

  const tol = CONFIG.HARMONICITY_BIN_TOLERANCE;
  let harmonicEnergy = 0;
  let totalEnergy = 0;

  // Sum total energy in range
  for (let i = startBin; i < endBin; i++) {
    totalEnergy += spectrum[i];
  }
  if (totalEnergy < 1) return 0;

  // Check energy at fundamental + harmonics (2x, 3x, ... Nx)
  for (let h = 1; h <= CONFIG.HARMONICITY_PARTIALS + 1; h++) {
    const harmonicBin = Math.round(fundamentalBin * h);
    if (harmonicBin >= endBin) break;

    // Sum energy within ±tolerance bins of each harmonic
    const lo = Math.max(startBin, harmonicBin - tol);
    const hi = Math.min(endBin - 1, harmonicBin + tol);
    for (let i = lo; i <= hi; i++) {
      harmonicEnergy += spectrum[i];
    }
  }

  return harmonicEnergy / totalEnergy;
}

// ========================================
// Multi-Feature Onset Detection (v9 — with harmonicity)
// ========================================
function updateMultiFeatureOnset(timeMs) {
  if (!onsetAnalyser || !onsetDataArray) return false;

  onsetAnalyser.getByteFrequencyData(onsetDataArray);

  const binHz = audioCtx.sampleRate / onsetAnalyser.fftSize;
  const startBin = Math.max(1, Math.floor(CONFIG.FLUX_FREQ_MIN_HZ / binHz));
  const endBin = Math.min(onsetDataArray.length, Math.floor(CONFIG.FLUX_FREQ_MAX_HZ / binHz));
  const numBins = endBin - startBin;

  if (numBins < 10) return (timeMs - state.lastOnsetTimeMs) < CONFIG.ONSET_GATE_DURATION_MS;

  if (!state.prevSpectrum) {
    state.prevSpectrum = new Float32Array(onsetDataArray.length);
    for (let i = 0; i < onsetDataArray.length; i++) {
      state.prevSpectrum[i] = onsetDataArray[i];
    }
    return false;
  }

  // Feature 1: Spectral Flux
  let flux = 0;
  let spreadCount = 0;
  for (let i = startBin; i < endBin; i++) {
    const diff = onsetDataArray[i] - state.prevSpectrum[i];
    if (diff > 0) {
      flux += diff;
      if (diff > CONFIG.ONSET_SPREAD_MIN_CHANGE) {
        spreadCount++;
      }
    }
  }
  const spread = spreadCount / numBins;

  // Feature 2: Spectral Flatness
  const flatness = computeSpectralFlatness(onsetDataArray, startBin, endBin);

  // Feature 3: Spectral Crest
  const crest = computeSpectralCrest(onsetDataArray, startBin, endBin);

  // Feature 4: Spectral Centroid (debug tracking)
  const centroid = computeSpectralCentroid(onsetDataArray, startBin, endBin, binHz);
  state.centroidHistory.push(centroid);
  if (state.centroidHistory.length > CONFIG.CENTROID_HISTORY_SIZE) {
    state.centroidHistory.shift();
  }
  const centroidCV = coefficientOfVariation(state.centroidHistory);

  // v9: Feature 5 — Harmonicity check
  let harmonicity = 0;
  let harmonicityOk = true; // default: pass if no pitch available
  if (state.debugLastPitch > CONFIG.PITCH_MIN_HZ) {
    const fundamentalBin = Math.round(state.debugLastPitch / binHz);
    harmonicity = computeHarmonicity(onsetDataArray, fundamentalBin, startBin, endBin);
    harmonicityOk = harmonicity >= CONFIG.HARMONICITY_MIN;
  }
  state.debugHarmonicity = harmonicity;

  // Save current spectrum for next frame
  for (let i = 0; i < onsetDataArray.length; i++) {
    state.prevSpectrum[i] = onsetDataArray[i];
  }

  // Update flux history for adaptive threshold
  const fHist = state.spectralFluxHistory;
  fHist.push(flux);
  if (fHist.length > CONFIG.SPECTRAL_FLUX_HISTORY_SIZE) fHist.shift();

  // Combined onset decision
  let isOnset = false;
  let onsetReason = '';
  if (fHist.length >= 5) {
    let mean = 0;
    for (let i = 0; i < fHist.length; i++) mean += fHist[i];
    mean /= fHist.length;

    let variance = 0;
    for (let i = 0; i < fHist.length; i++) {
      const d = fHist[i] - mean;
      variance += d * d;
    }
    variance /= fHist.length;
    const stddev = Math.sqrt(variance);

    const adaptiveThreshold = mean + CONFIG.SPECTRAL_FLUX_ADAPTIVE_K * stddev;
    const threshold = Math.max(CONFIG.SPECTRAL_FLUX_THRESHOLD, adaptiveThreshold);

    state.debugLastThreshold = threshold;

    const fluxOk = flux > threshold;
    const spreadOk = spread > CONFIG.ONSET_SPREAD_THRESHOLD;
    const flatnessOk = flatness > CONFIG.FLATNESS_PIANO_MIN;
    const crestOk = crest < CONFIG.CREST_VOICE_MAX;

    // v9: 5-condition gate (added harmonicity)
    if (fluxOk && spreadOk && flatnessOk && crestOk && harmonicityOk) {
      if (timeMs - state.lastOnsetTimeMs > CONFIG.ONSET_COOLDOWN_MS) {
        state.lastOnsetTimeMs = timeMs;
        isOnset = true;
        onsetReason = 'PIANO';
        // v9: reset voice rejection counter on successful detection
        state.agcVoiceRejectCount = 0;
      }
    } else if (fluxOk && spreadOk) {
      // v9: track rejections for AGC voice suppression
      if (state.debugLastRms > CONFIG.AGC_VOICE_RMS_MIN) {
        state.agcVoiceRejectCount++;
        if (state.agcVoiceRejectCount >= CONFIG.AGC_VOICE_REJECT_COUNT) {
          state.agcVoiceSuppressUntilMs = timeMs + CONFIG.AGC_VOICE_SUPPRESS_MS;
        }
      }
      if (!harmonicityOk) onsetReason = 'REJ:harm';
      else if (!flatnessOk) onsetReason = 'REJ:flat';
      else if (!crestOk) onsetReason = 'REJ:crest';
    }
  }

  // Store debug info
  state.debugLastFlux = flux;
  state.debugLastSpread = spread;
  state.debugLastFlatness = flatness;
  state.debugLastCrest = crest;
  state.debugOnsetReason = onsetReason;
  state.debugLastCentroid = centroid;
  state.debugCentroidCV = centroidCV;

  const gateOpen = (timeMs - state.lastOnsetTimeMs) < CONFIG.ONSET_GATE_DURATION_MS;
  state.debugGateOpen = gateOpen;

  return gateOpen;
}

// ========================================
// Session Confidence Layer
// ========================================
function updateSessionConfidence(timeMs, isPianoDetected) {
  if (timeMs - state.lastSessionSampleMs < CONFIG.SESSION_SAMPLE_INTERVAL_MS) return;
  state.lastSessionSampleMs = timeMs;

  state.sessionSamples.push({ timeMs: timeMs, isPiano: isPianoDetected });

  const windowStart = timeMs - CONFIG.SESSION_WINDOW_MS;
  while (state.sessionSamples.length > 0 && state.sessionSamples[0].timeMs < windowStart) {
    state.sessionSamples.shift();
  }

  if (state.sessionSamples.length < 3) {
    state.sessionConfidence = 0;
    return;
  }

  let pianoCount = 0;
  for (let i = 0; i < state.sessionSamples.length; i++) {
    if (state.sessionSamples[i].isPiano) pianoCount++;
  }
  state.sessionConfidence = pianoCount / state.sessionSamples.length;

  state.debugSessionConf = state.sessionConfidence;

  const prevState = state.sessionState;

  switch (state.sessionState) {
    case 'waiting':
      if (state.sessionConfidence >= CONFIG.SESSION_CONFIRM_THRESHOLD) {
        state.sessionState = 'warmup';
        state.sessionStartMs = timeMs;
      }
      break;

    case 'warmup':
      if (state.sessionConfidence < CONFIG.SESSION_LOSE_THRESHOLD) {
        state.sessionState = 'waiting';
      } else if (timeMs - state.sessionStartMs >= CONFIG.SESSION_WARMUP_MS
                 && state.sessionConfidence >= CONFIG.SESSION_CONFIRM_THRESHOLD) {
        state.sessionState = 'performing';
        state.sessionPerformingStartMs = timeMs;
      }
      break;

    case 'performing':
      if (state.sessionConfidence < CONFIG.SESSION_LOSE_THRESHOLD) {
        state.sessionState = 'warmup';
        state.sessionStartMs = timeMs;
      }
      break;
  }

  state.debugSessionState = state.sessionState;

  // Update visual indicator
  if (state.sessionState === 'warmup') {
    const warmupProgress = Math.min(1, (timeMs - state.sessionStartMs) / CONFIG.SESSION_WARMUP_MS);
    const dots = Math.floor(warmupProgress * 3) + 1;
    DOM.sessionStatus.textContent = '\u266B '.repeat(dots) + 'きいてるよ' + ' \u266B'.repeat(dots);
    DOM.sessionStatus.classList.add('visible');
  } else if (state.sessionState === 'performing') {
    if (timeMs - state.sessionPerformingStartMs < 2000) {
      DOM.sessionStatus.textContent = '\u2728 すてき！ \u2728';
      DOM.sessionStatus.classList.add('visible');
    } else {
      DOM.sessionStatus.classList.remove('visible');
    }
  } else {
    DOM.sessionStatus.classList.remove('visible');
  }
}

// ========================================
// Quality Scoring — simplified for kids
// ========================================

function computeRhythmScore() {
  const ioi = state.ioiHistory;
  if (ioi.length < 3) return 0.5;
  const cv = coefficientOfVariation(ioi);
  if (cv <= CONFIG.IOI_IDEAL_CV) return 0.85 + 0.15 * (1 - cv / CONFIG.IOI_IDEAL_CV);
  if (cv <= CONFIG.IOI_MAX_CV) {
    const t = (cv - CONFIG.IOI_IDEAL_CV) / (CONFIG.IOI_MAX_CV - CONFIG.IOI_IDEAL_CV);
    return 0.85 - 0.45 * t;
  }
  return 0.4;
}

function computeDynamicsScore() {
  const amps = state.amplitudeHistory;
  if (amps.length < 3) return 0.5;
  const cv = coefficientOfVariation(amps);
  if (cv >= CONFIG.DYNAMICS_IDEAL_CV_MIN && cv <= CONFIG.DYNAMICS_IDEAL_CV_MAX) {
    return 0.8 + 0.2 * (1 - Math.abs(cv - 0.15) / 0.45);
  } else if (cv < CONFIG.DYNAMICS_IDEAL_CV_MIN) {
    return 0.6;
  } else {
    return Math.max(0.3, 0.8 - (cv - CONFIG.DYNAMICS_IDEAL_CV_MAX) * 0.5);
  }
}

function updateQualityScores(timeMs) {
  if (timeMs - state.lastScoreUpdateMs < CONFIG.SCORE_UPDATE_INTERVAL_MS) return;
  state.lastScoreUpdateMs = timeMs;

  state.rhythmScore = computeRhythmScore();
  state.dynamicsScore = computeDynamicsScore();

  state.qualityScore =
    state.rhythmScore * CONFIG.SCORE_RHYTHM_WEIGHT +
    state.dynamicsScore * CONFIG.SCORE_DYNAMICS_WEIGHT;

  state.displayedQualityScore += (state.qualityScore - state.displayedQualityScore) * CONFIG.SCORE_SMOOTHING;

  // v9: Warmer quality labels
  if (state.sessionState === 'performing' && state.displayedQualityScore > 0.3) {
    const stars = Math.floor(state.displayedQualityScore * 5);
    const label = stars >= 4 ? 'うっとり！' : stars >= 3 ? 'すてき！' : stars >= 2 ? 'いいかんじ！' : '';
    DOM.qualityScore.textContent = '\u2605'.repeat(stars) + '\u2606'.repeat(5 - stars) + (label ? ' ' + label : '');
    DOM.qualityScore.classList.add('visible');
  } else {
    DOM.qualityScore.classList.remove('visible');
  }
}

// ========================================
// Software AGC — with v9 voice suppression
// ========================================
function updateAGC(timeMs, postGainRms) {
  if (timeMs - state.agcLastUpdateMs < CONFIG.AGC_UPDATE_INTERVAL_MS) return;
  state.agcLastUpdateMs = timeMs;

  state.agcSmoothedRms += (postGainRms - state.agcSmoothedRms) * 0.15;

  const preGainRms = state.agcSmoothedRms / state.agcGain;
  if (preGainRms < CONFIG.AGC_SILENCE_FLOOR) return;

  // v9: Determine effective max gain — suppress during voice detection
  const effectiveMaxGain = (timeMs < state.agcVoiceSuppressUntilMs)
    ? CONFIG.AGC_VOICE_SUPPRESS_MAX
    : CONFIG.AGC_MAX_GAIN;

  const ratio = CONFIG.AGC_TARGET_RMS / (state.agcSmoothedRms + 1e-10);
  const targetGain = Math.max(CONFIG.AGC_MIN_GAIN, Math.min(effectiveMaxGain, state.agcGain * ratio));

  const alpha = targetGain > state.agcGain ? CONFIG.AGC_ATTACK_COEFF : CONFIG.AGC_RELEASE_COEFF;
  state.agcGain += (targetGain - state.agcGain) * alpha;
  state.agcGain = Math.max(CONFIG.AGC_MIN_GAIN, Math.min(effectiveMaxGain, state.agcGain));

  gainNode.gain.setValueAtTime(state.agcGain, audioCtx.currentTime);
  state.debugAgcGain = state.agcGain;
}

// ========================================
// Game Logic — 4-layer architecture (v9)
// ========================================
function updateGameState(timeMs, dt, pitchResult) {
  const { pitch, conf, rms } = pitchResult;

  const hasRecentOnset = updateMultiFeatureOnset(timeMs);

  const pitchOk = pitch > CONFIG.PITCH_MIN_HZ && pitch < CONFIG.PITCH_MAX_HZ
    && conf > CONFIG.CONFIDENCE_THRESHOLD && rms > CONFIG.GOOD_NOTE_RMS;
  const isGoodNote = pitchOk && hasRecentOnset;

  state.debugLastRms = rms;
  state.debugLastConf = conf;
  state.debugLastPitch = pitch;
  state.debugIsGoodNote = isGoodNote;

  updateSessionConfidence(timeMs, isGoodNote);

  if (isGoodNote) {
    const lastOnset = state.noteOnsetTimes.length > 0
      ? state.noteOnsetTimes[state.noteOnsetTimes.length - 1] : 0;
    if (timeMs - lastOnset > 80) {
      state.noteOnsetTimes.push(timeMs);
      if (state.noteOnsetTimes.length > CONFIG.IOI_HISTORY_SIZE + 1) {
        state.noteOnsetTimes.shift();
      }
      if (state.noteOnsetTimes.length >= 2) {
        const ioi = timeMs - state.noteOnsetTimes[state.noteOnsetTimes.length - 2];
        if (ioi > 100 && ioi < 5000) {
          state.ioiHistory.push(ioi);
          if (state.ioiHistory.length > CONFIG.IOI_HISTORY_SIZE) {
            state.ioiHistory.shift();
          }
        }
      }
    }

    state.amplitudeHistory.push(rms);
    if (state.amplitudeHistory.length > CONFIG.AMPLITUDE_HISTORY_SIZE) {
      state.amplitudeHistory.shift();
    }
  }

  updateQualityScores(timeMs);

  const dtSec = dt / 1000;
  const isPerforming = state.sessionState === 'performing';
  const isWarmup = state.sessionState === 'warmup';

  if (isGoodNote) {
    if (state.lastPitch > 0) {
      const semitones = Math.abs(12 * Math.log2(pitch / state.lastPitch));
      if (semitones < CONFIG.STABILITY_SEMITONE_THRESHOLD) {
        state.pitchStability = Math.min(1, state.pitchStability + CONFIG.STABILITY_GROWTH);
      } else {
        state.pitchStability *= CONFIG.STABILITY_DECAY_GOOD;
      }
    }
    state.lastPitch = pitch;
    state.lastSilenceStartMs = -1;

    if (isPerforming || isWarmup) {
      if (state.lastGoodNoteTimeMs > 0 && (timeMs - state.lastGoodNoteTimeMs) < CONFIG.COMBO_WINDOW_MS) {
        state.combo++;
        if (state.combo > state.bestCombo) {
          state.bestCombo = state.combo;
        }
      } else {
        state.combo = Math.max(1, Math.floor(state.combo * 0.6));
      }
    }
    state.lastGoodNoteTimeMs = timeMs;

    if (isPerforming) {
      const comboFactor = Math.min(state.combo / 50, 1);
      const qualityFactor = state.qualityScore;
      const flowGain = (CONFIG.FLOW_GAIN_BASE
        + comboFactor * CONFIG.FLOW_GAIN_COMBO_MAX
        + state.pitchStability * CONFIG.FLOW_GAIN_STABILITY_MAX
        + qualityFactor * CONFIG.FLOW_GAIN_QUALITY_MAX) * dtSec;
      state.flow = Math.min(100, state.flow + flowGain);
    } else if (isWarmup) {
      state.flow = Math.min(8, state.flow + 2 * dtSec);
    }

  } else {
    state.pitchStability *= CONFIG.STABILITY_DECAY_IDLE;

    if (state.lastSilenceStartMs < 0) {
      state.lastSilenceStartMs = timeMs;
    }
    const silenceDuration = timeMs - state.lastSilenceStartMs;

    if (silenceDuration > CONFIG.SILENCE_DECAY_START_MS) {
      state.flow = Math.max(0, state.flow - CONFIG.FLOW_DECAY_SOFT * dtSec);
      if (silenceDuration > CONFIG.SILENCE_HARD_DECAY_MS) {
        state.flow = Math.max(0, state.flow - CONFIG.FLOW_DECAY_HARD * dtSec);
        state.combo = Math.max(0, state.combo - Math.ceil(CONFIG.COMBO_DECAY_RATE * dtSec * 60));
      }
    }

    if (rms > CONFIG.NOISE_RMS_THRESHOLD && !isGoodNote) {
      if (timeMs - state.lastNoisePenaltyMs > CONFIG.NOISE_PENALTY_COOLDOWN_MS) {
        state.flow = Math.max(0, state.flow - CONFIG.FLOW_NOISE_PENALTY * dtSec);
        state.combo = Math.max(0, state.combo - CONFIG.COMBO_NOISE_PENALTY);
        state.lastNoisePenaltyMs = timeMs;
      }
    }
  }

  // Stage transitions — v9: enhanced with more particles
  const prevStage = state.currentStage;
  let newStage = 0;
  for (let i = CONFIG.STAGES.length - 1; i >= 0; i--) {
    if (state.flow >= CONFIG.STAGES[i].minFlow) { newStage = i; break; }
  }

  if (newStage !== prevStage) {
    state.currentStage = newStage;
    DOM.stageLabel.textContent = CONFIG.STAGES[newStage].name;
    if (newStage > 0) { DOM.stageLabel.classList.add('visible'); }
    else { DOM.stageLabel.classList.remove('visible'); }

    // v9: Enhanced stage-up celebration
    if (newStage > prevStage && newStage > 0) {
      for (let i = 0; i < 40; i++) {
        spawnBurst(Math.random() * W, Math.random() * H, 3, 0.9);
      }
      effectStarShower(6);
    }
  }

  updateHUD(timeMs);
  return isGoodNote;
}

// ========================================
// v9: updateHUD — encouragement instead of numbers
// ========================================
function updateHUD(timeMs) {
  // v9: Check encouragement tiers (find highest matching tier)
  let bestTier = -1;
  for (let i = CONFIG.ENCOURAGEMENT_TIERS.length - 1; i >= 0; i--) {
    if (state.combo >= CONFIG.ENCOURAGEMENT_TIERS[i].minCombo) {
      bestTier = i;
      break;
    }
  }

  // Show encouragement when tier increases
  if (bestTier > state.currentEncouragementTier && bestTier >= 0) {
    showEncouragement(bestTier, timeMs);
  }

  // Reset tier tracking when combo drops
  if (bestTier < state.currentEncouragementTier) {
    state.currentEncouragementTier = bestTier;
  }

  // Hide encouragement after display time
  if (timeMs > state.encouragementHideTimeMs) {
    DOM.encouragement.classList.remove('visible');
  }

  // Flow gauge
  DOM.flowFill.style.height = state.flow + '%';
  const hue = state.flow * 1.2 + 200;
  DOM.flowFill.style.background = 'linear-gradient(to top,hsl(' + hue + ',70%,40%),hsl(' + (hue + 40) + ',80%,60%))';
  DOM.flowFill.style.boxShadow = '0 0 ' + (state.flow * 0.3) + 'px hsl(' + hue + ',70%,60%)';
}

// ========================================
// Debug overlay (v9)
// ========================================
function updateDebugOverlay() {
  if (!state.debugMode) return;
  const gateMs = Math.max(0, CONFIG.ONSET_GATE_DURATION_MS - (performance.now() - state.lastOnsetTimeMs));
  const voiceSupp = state.agcVoiceSuppressUntilMs > performance.now() ? 'SUPP' : 'ok';
  DOM.debugOverlay.textContent =
    'v9 YIN+Harm+SoftAGC | FLUX: ' + state.debugLastFlux.toFixed(1) +
    '  THR: ' + state.debugLastThreshold.toFixed(1) +
    '  SPR: ' + (state.debugLastSpread * 100).toFixed(0) + '%' +
    '\nFLAT: ' + state.debugLastFlatness.toFixed(3) +
    '  CREST: ' + state.debugLastCrest.toFixed(1) +
    '  HARM: ' + state.debugHarmonicity.toFixed(3) +
    '  ' + state.debugOnsetReason +
    '\nGATE: ' + (state.debugGateOpen ? 'OPEN ' + (gateMs / 1000).toFixed(1) + 's' : 'CLOSED') +
    '  RMS: ' + state.debugLastRms.toFixed(4) +
    '  AGC: x' + state.debugAgcGain.toFixed(1) + ' ' + voiceSupp +
    '\nPITCH: ' + (state.debugLastPitch > 0 ? state.debugLastPitch.toFixed(1) + 'Hz' : '---') +
    '  CONF: ' + state.debugLastConf.toFixed(2) +
    '  NOTE: ' + (state.debugIsGoodNote ? 'YES' : 'no') +
    '\nSESSION: ' + state.debugSessionState.toUpperCase() +
    '  S.CONF: ' + (state.debugSessionConf * 100).toFixed(0) + '%' +
    '\nQUALITY: ' + (state.qualityScore * 100).toFixed(0) + '%' +
    '  R:' + (state.rhythmScore * 100).toFixed(0) +
    ' D:' + (state.dynamicsScore * 100).toFixed(0) +
    '\nFLOW: ' + state.flow.toFixed(1) +
    '  COMBO: ' + state.combo +
    '  STAGE: ' + state.currentStage;
}

// ========================================
// Energy calculation
// ========================================
function getEnergy() {
  if (!analyser) return 0;
  analyser.getByteFrequencyData(dataArray);
  let sum = 0;
  const binHz = audioCtx.sampleRate / analyser.fftSize;
  const s = Math.floor(CONFIG.PIANO_FREQ_MIN / binHz);
  const e = Math.min(Math.floor(CONFIG.PIANO_FREQ_MAX / binHz), dataArray.length);
  for (let i = s; i < e; i++) sum += dataArray[i];
  return sum / ((e - s) * 255);
}

// ========================================
// Main Loop
// ========================================
function loop(timeMs) {
  if (!state.running) return;
  requestAnimationFrame(loop);

  const dt = state.lastFrameTimeMs > 0 ? Math.min(timeMs - state.lastFrameTimeMs, 50) : 16;
  state.lastFrameTimeMs = timeMs;

  const theme = CONFIG.THEMES[state.currentTheme];
  const energy = getEnergy();
  state.smoothEnergy += (energy - state.smoothEnergy) * 0.15;

  const [br, bg2, bb] = theme.bg;
  const fadeRate = 0.08 + 0.06 * (1 - state.flow / 100);
  ctx.fillStyle = 'rgba(' + br + ',' + bg2 + ',' + bb + ',' + fadeRate + ')';
  ctx.fillRect(0, 0, W, H);

  drawBgStars(timeMs);
  drawAurora(timeMs);
  drawGroundFlowers(timeMs);

  // v9: Glow pulse effect (from encouragement)
  const glowExtra = state.glowPulseIntensity;
  if (glowExtra > 0.01) {
    state.glowPulseIntensity *= 0.96; // decay
  }

  if (state.smoothEnergy > 0.04 || glowExtra > 0.02) {
    const baseGlow = W * 0.3 * state.smoothEnergy + 100 + state.flow * 3;
    const glowSize = baseGlow + glowExtra * W * 0.2;
    const glowAlpha = 0.08 + state.flow * 0.002 + glowExtra * 0.15;
    const grad = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, glowSize);
    grad.addColorStop(0, theme.glow + Math.min(glowAlpha, 0.4) + ')');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
  }

  // v9: Shimmer effect
  if (state.shimmerPhase >= 0) {
    const shimmerAge = timeMs - state.shimmerStartMs;
    if (shimmerAge < 1500) {
      const shimmerAlpha = 0.08 * Math.sin(shimmerAge * 0.02) * (1 - shimmerAge / 1500);
      if (shimmerAlpha > 0) {
        ctx.fillStyle = 'rgba(255,255,255,' + shimmerAlpha + ')';
        ctx.fillRect(0, 0, W, H);
      }
    } else {
      state.shimmerPhase = -1;
    }
  }

  let isGoodNote = false;
  if (analyser) {
    analyser.getFloatTimeDomainData(freqArray);
    const pitchResult = detectPitchYIN(freqArray, audioCtx.sampleRate);

    updateAGC(timeMs, pitchResult.rms);

    isGoodNote = updateGameState(timeMs, dt, pitchResult);

    if (isGoodNote && pitchResult.pitch > CONFIG.PITCH_MIN_HZ) {
      const note = freqToNote(pitchResult.pitch);
      if (note) {
        const noteX = ((note.noteNum - CONFIG.PIANO_KEY_MIN) / CONFIG.PIANO_KEY_COUNT) * W;
        const noteY = H * 0.45 + (Math.random() - 0.5) * H * 0.25;

        if (timeMs - state.lastNoteTimeMs > CONFIG.MIN_NOTE_INTERVAL_MS) {
          const burstSize = Math.floor(4 + state.smoothEnergy * 20 + state.flow * 0.15);
          spawnBurst(noteX, noteY, burstSize, state.smoothEnergy * (1 + state.flow * 0.02));
          const rippleSize = 150 + state.flow * 2 + state.combo * 0.5;
          ripples.push(new Ripple(noteX, noteY, theme.colors[note.noteNum % theme.colors.length], rippleSize));
          state.lastNoteTimeMs = timeMs;
        }
        spawnStream(noteX, H * 0.65, state.smoothEnergy);

        const displayNote = note.name + note.octave;
        if (displayNote !== state.lastDetectedNote) {
          state.lastDetectedNote = displayNote;
          state.noteShowTimeMs = timeMs;
          DOM.noteDisplay.textContent = note.name;
          DOM.noteDisplay.classList.add('visible');
        }
      }
    }
  }

  if (timeMs - state.noteShowTimeMs > CONFIG.NOTE_DISPLAY_DURATION_MS) {
    DOM.noteDisplay.classList.remove('visible');
  }

  if (state.smoothEnergy < 0.04 && Math.random() > (1 - CONFIG.AMBIENT_PARTICLE_CHANCE - state.flow * 0.003)) {
    const cols = theme.colors;
    if (particles.length < CONFIG.MAX_PARTICLES) {
      particles.push(new Particle(
        Math.random() * W, H + 10,
        cols[Math.floor(Math.random() * cols.length)],
        1 + Math.random() * (1 + state.flow * 0.03),
        (Math.random() - 0.5) * 0.3, -0.3 - Math.random() * 0.5 - state.flow * 0.005,
        200 + Math.random() * 100, 'circle'
      ));
    }
  }

  if (analyser && state.smoothEnergy > 0.03) {
    const binHz = audioCtx.sampleRate / analyser.fftSize;
    const sB = Math.floor(CONFIG.PIANO_FREQ_MIN / binHz);
    const eB = Math.floor(CONFIG.PIANO_FREQ_MAX / binHz);
    const step = Math.floor((eB - sB) / CONFIG.BAR_COUNT);
    const barW = W / CONFIG.BAR_COUNT;
    const barAlphaScale = 0.15 + state.flow * 0.003;
    for (let i = 0; i < CONFIG.BAR_COUNT; i++) {
      const idx = sB + i * step;
      const val = dataArray[idx] / 255;
      const barH = val * H * (0.1 + state.flow * 0.001);
      ctx.fillStyle = theme.colors[Math.floor((i / CONFIG.BAR_COUNT) * theme.colors.length) % theme.colors.length];
      ctx.globalAlpha = val * barAlphaScale;
      ctx.fillRect(i * barW, H - barH, barW - 1, barH);
    }
    ctx.globalAlpha = 1;
  }

  for (let i = ripples.length - 1; i >= 0; i--) {
    ripples[i].update(); ripples[i].draw(ctx);
    if (ripples[i].life <= 0) ripples.splice(i, 1);
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update(); particles[i].draw(ctx);
    if (particles[i].life <= 0) particles.splice(i, 1);
  }
  if (particles.length > CONFIG.MAX_PARTICLES) {
    particles.splice(0, particles.length - CONFIG.MAX_PARTICLES);
  }

  updateDebugOverlay();
}

// ========================================
// Start
// ========================================
DOM.startBtn.addEventListener('click', async () => {
  try {
    await initAudio();
    DOM.startScreen.style.display = 'none';
    DOM.themeBar.classList.add('visible');
    DOM.hud.style.display = 'block';
    initBgStars();
    state.running = true;
    state.lastFrameTimeMs = 0;
    requestAnimationFrame(loop);
  } catch (e) {
    alert('マイクへのアクセスを許可してください\n\niPadの場合：設定 > Safari > マイク で確認できます');
  }
});
</script>
</body>
</html>
